<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>METEOROLOG√çA Y AHORRO - Espa√±a</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2980b9;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --danger-color: #e74c3c;
            --text-color: #2c3e50;
            --bg-color: #ecf0f1;
            --card-bg: #ffffff;
            --border-radius: 12px;
            --box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: var(--text-color);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .card {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: var(--box-shadow);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
        }

        .card h3 {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 1.5rem;
            text-align: center;
        }

        .info-box {
            background: linear-gradient(135deg, #e8f4fd, #d1ecf1);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid var(--primary-color);
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .input-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .input-group input {
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            min-width: 250px;
        }

        .input-group button {
            padding: 12px 20px;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .input-group button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.3);
        }

        .chart-container {
            margin-top: 20px;
            height: 400px;
            position: relative;
        }

        .chart-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .chart-controls label {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            background: #f8f9fa;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .chart-controls label:hover {
            background: #e9ecef;
            transform: translateY(-2px);
        }

        .chart-controls label.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--secondary-color);
        }

        .chart-controls input[type="checkbox"] {
            margin: 0;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .back-button {
            display: inline-block;
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            text-decoration: none;
            padding: 12px 25px;
            border-radius: 25px;
            font-weight: 600;
            font-size: 0.95rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 20px;
        }

        .back-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.6);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: white;
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            color: rgba(255,255,255,0.9);
            font-size: 1.1rem;
        }

        #weather {
            min-height: 100px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        #map {
            height: 400px;
            border-radius: 12px;
            margin-top: 15px;
            border: 2px solid #ddd;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .input-group {
                flex-direction: column;
                width: 100%;
            }
            
            .input-group input {
                min-width: 100%;
            }
            
            .chart-controls {
                flex-direction: column;
                align-items: center;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }

        /* Estilos para Recomendaciones de Ahorro Energ√©tico */
        .alertas-container {
            margin-bottom: 20px;
        }

        .alerta {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 5px solid;
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 500;
            animation: slideIn 0.5s ease-out;
        }

        .alerta.critica {
            background: linear-gradient(135deg, #ffe6e6, #ffcccc);
            border-left-color: #e74c3c;
            color: #c0392b;
        }

        .alerta.advertencia {
            background: linear-gradient(135deg, #fff4e6, #ffe6cc);
            border-left-color: #f39c12;
            color: #d68910;
        }

        .alerta.info {
            background: linear-gradient(135deg, #e6f3ff, #cce7ff);
            border-left-color: #3498db;
            color: #2980b9;
        }

        .alerta.positiva {
            background: linear-gradient(135deg, #e8f5e8, #d4f1d4);
            border-left-color: #27ae60;
            color: #229954;
        }

        .recomendaciones-container {
            margin-bottom: 25px;
        }

        .recomendaciones-container h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 8px;
        }

        .consejos-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }

        .consejo {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 15px;
            transition: all 0.3s ease;
            border-left: 4px solid;
        }

        .consejo:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .consejo.calefaccion {
            border-left-color: #e74c3c;
        }

        .consejo.refrigeracion {
            border-left-color: #3498db;
        }

        .consejo.ventilacion {
            border-left-color: #f39c12;
        }

        .consejo.general {
            border-left-color: #27ae60;
        }

        .consejo.iluminacion {
            border-left-color: #9b59b6;
        }

        .consejo-titulo {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .consejo-descripcion {
            color: #5d6d7e;
            font-size: 0.95em;
            line-height: 1.4;
        }

        .consejos-timeline {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .franja-horaria {
            background: linear-gradient(135deg, #fdfdfe, #f4f6f7);
            border: 1px solid #d5dbdb;
            border-radius: 8px;
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .franja-hora {
            font-weight: bold;
            color: #2c3e50;
            min-width: 80px;
        }

        .franja-consejo {
            flex: 1;
            color: #5d6d7e;
        }

        .franja-ahorro {
            font-weight: 600;
            color: #27ae60;
            font-size: 0.9em;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üå§Ô∏è METEOROLOG√çA Y AHORRO</h1>
            <p>Datos del tiempo y recomendaciones de eficiencia energ√©tica para Espa√±a</p>
        </div>

        <div style="text-align: center; margin-bottom: 30px;">
            <a href="index.html" class="back-button">
                ‚Üê Volver al Dashboard Principal
            </a>
        </div>

        <!-- Weather Card -->
        <div class="card" id="info-meteorologica">
            <h3>üå§Ô∏è Informaci√≥n Meteorol√≥gica</h3>
            
            <!-- Bot√≥n para refrescar datos meteorol√≥gicos -->
            <div style="text-align: center; margin-bottom: 15px; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                <button onclick="refreshWeatherData()" style="
                  background: linear-gradient(45deg, #3498db, #2980b9);
                  color: white;
                  border: none;
                  padding: 10px 20px;
                  border-radius: 8px;
                  cursor: pointer;
                  font-size: 14px;
                  font-weight: 700;
                  transition: all 0.3s ease;
                  box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
                " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(52, 152, 219, 0.5)'" 
                   onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(52, 152, 219, 0.4)'">
                  üîÑ ACTUALIZAR DATOS METEOROL√ìGICOS
                </button>
                <button onclick="clearSessionCache()" style="
                  background: linear-gradient(45deg, #e74c3c, #c0392b);
                  color: white;
                  border: none;
                  padding: 10px 20px;
                  border-radius: 8px;
                  cursor: pointer;
                  font-size: 14px;
                  font-weight: 700;
                  transition: all 0.3s ease;
                  box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
                " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(231, 76, 60, 0.5)'" 
                   onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(231, 76, 60, 0.4)'">
                  üßπ LIMPIAR CACH√â
                </button>
            </div>
            
            <div id="weather">
                <span class="loading"></span>Cargando informaci√≥n meteorol√≥gica...
            </div>
            
            <div class="chart-controls">
                <label id="temp-label" class="active">
                    <input type="checkbox" id="temp-checkbox" checked> 
                    <span>üå°Ô∏è Temperatura</span>
                </label>
                <label id="humidity-label">
                    <input type="checkbox" id="humidity-checkbox"> 
                    <span>üíß Humedad</span>
                </label>
                <label id="precipitation-label">
                    <input type="checkbox" id="precipitation-checkbox"> 
                    <span>üåßÔ∏è Precipitaciones</span>
                </label>
            </div>
            
            <div class="chart-container">
                <canvas id="weather-chart"></canvas>
            </div>
        </div>

        <!-- Recomendaciones de Ahorro Energ√©tico -->
        <div class="card" id="recomendaciones-energia">
            <h3>üí° Recomendaciones de Ahorro Energ√©tico</h3>
            <div class="info-box">
                <p><strong>üéØ Prop√≥sito:</strong> Consejos inteligentes basados en las condiciones meteorol√≥gicas actuales y pron√≥stico del d√≠a.</p>
                <p><strong>‚ö° Beneficio:</strong> Optimiza tu consumo energ√©tico seg√∫n la temperatura, humedad y condiciones clim√°ticas.</p>
            </div>
            
            <!-- Alertas Importantes -->
            <div id="alertas-energia" class="alertas-container">
                <!-- Las alertas se generar√°n din√°micamente -->
            </div>
            
            <!-- Recomendaciones del D√≠a -->
            <div id="recomendaciones-dia" class="recomendaciones-container">
                <h4>üìÖ Recomendaciones para Hoy</h4>
                <div id="consejos-dia" class="consejos-grid">
                    <!-- Los consejos se generar√°n din√°micamente -->
                </div>
            </div>
            
            <!-- Recomendaciones por Horas -->
            <div id="recomendaciones-horas" class="recomendaciones-container">
                <h4>üïí Recomendaciones por Franjas Horarias</h4>
                <div id="consejos-horas" class="consejos-timeline">
                    <!-- Los consejos por horas se generar√°n din√°micamente -->
                </div>
            </div>
        </div>

        <!-- Map Card -->
        <div class="card" id="mapa-ubicacion">
            <h3>üìç Ubicaci√≥n en Espa√±a</h3>
            <div class="info-box">
                <p><strong>üéØ Prop√≥sito:</strong> La p√°gina detecta autom√°ticamente tu ubicaci√≥n y carga datos meteorol√≥gicos locales espec√≠ficos.</p>
                <p><strong>üñ±Ô∏è Interactividad:</strong> Haz <strong>doble click</strong> en cualquier parte del mapa para obtener detalles meteorol√≥gicos precisos de esa zona dentro del territorio espa√±ol.</p>
                <p><strong>üåç Cobertura:</strong> Toda Espa√±a, incluyendo Baleares y Canarias. Los datos se actualizan autom√°ticamente seg√∫n la ubicaci√≥n seleccionada.</p>
                <p><strong>üìç Estado:</strong> <span id="location-status">Detectando ubicaci√≥n...</span></p>
            </div>
            <div class="controls">
                <div class="input-group">
                    <input type="text" id="ciudad" placeholder="Ej: Madrid, Barcelona, Valencia, Sevilla, Bilbao...">
                    <button onclick="buscarCiudad()">üîç Buscar</button>
                </div>
            </div>
            <div id="map"></div>
        </div>
    </div>

    <script>
        // Variables globales
        let map = null;
        let currentMarker = null;
        let weatherChart = null;
        let currentLocation = {
            name: 'Madrid',
            lat: 40.4168,
            lon: -3.7038,
            country: 'Espa√±a',
            detected: false
        };

        // Funci√≥n para detectar ubicaci√≥n del usuario
        async function detectUserLocation() {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    console.log('üö´ Geolocalizaci√≥n no soportada por el navegador');
                    resolve(false);
                    return;
                }

                console.log('üåç Detectando ubicaci√≥n del usuario...');
                
                navigator.geolocation.getCurrentPosition(
                    async (position) => {
                        const lat = position.coords.latitude;
                        const lon = position.coords.longitude;
                        
                        console.log(`üìç Coordenadas detectadas: ${lat}, ${lon}`);
                        
                        // Verificar si est√° en territorio espa√±ol (aproximadamente)
                        if (lat >= 35.0 && lat <= 44.0 && lon >= -10.0 && lon <= 5.0) {
                            try {
                                // Obtener nombre de la ciudad usando geocoding reverso
                                const cityName = await getCityName(lat, lon);
                                
                                currentLocation = {
                                    name: cityName,
                                    lat: lat,
                                    lon: lon,
                                    country: 'Espa√±a',
                                    detected: true
                                };
                                
                                console.log(`‚úÖ Ubicaci√≥n detectada: ${cityName}, Espa√±a`);
                                resolve(true);
                            } catch (error) {
                                console.warn('‚ö†Ô∏è Error obteniendo nombre de ciudad:', error);
                                resolve(false);
                            }
                        } else {
                            console.log('üèÅ Usuario fuera de Espa√±a, usando Madrid por defecto');
                            resolve(false);
                        }
                    },
                    (error) => {
                        console.warn('‚ùå Error de geolocalizaci√≥n:', error.message);
                        resolve(false);
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 300000 // 5 minutos
                    }
                );
            });
        }

        // Funci√≥n para obtener nombre de ciudad usando geocoding reverso
        async function getCityName(lat, lon) {
            try {
                // Usar OpenStreetMap Nominatim (gratuito)
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&accept-language=es`);
                
                if (!response.ok) throw new Error('Geocoding API error');
                
                const data = await response.json();
                
                // Extraer nombre de ciudad/pueblo
                const city = data.address?.city || 
                           data.address?.town || 
                           data.address?.village || 
                           data.address?.municipality ||
                           data.address?.state ||
                           'Ubicaci√≥n detectada';
                
                return city;
            } catch (error) {
                console.warn('Error en geocoding:', error);
                return 'Ubicaci√≥n detectada';
            }
        }

        // Configuraci√≥n de cach√©
        const CACHE_CONFIG = {
            WEATHER_TTL: 15 * 60 * 1000,         // 15 minutos
            MAX_WEATHER_CALLS_PER_DAY: 800       // L√≠mite de seguridad
        };

        // Clase para gesti√≥n de cach√©
        class CacheManager {
            constructor() {
                this.sessionCounters = new Map();
            }

            canMakeWeatherCall() {
                const today = new Date().toDateString();
                const sessionKey = `weather_calls_${today}`;
                const current = parseInt(sessionStorage.getItem(sessionKey) || '0');
                
                if (current >= CACHE_CONFIG.MAX_WEATHER_CALLS_PER_DAY) {
                    console.warn(`‚ö†Ô∏è L√≠mite de llamadas meteorol√≥gicas alcanzado: ${current}/${CACHE_CONFIG.MAX_WEATHER_CALLS_PER_DAY}`);
                    return false;
                }
                
                return true;
            }

            incrementWeatherCallCounter() {
                const today = new Date().toDateString();
                const sessionKey = `weather_calls_${today}`;
                const current = parseInt(sessionStorage.getItem(sessionKey) || '0');
                sessionStorage.setItem(sessionKey, (current + 1).toString());
                console.log(`üå§Ô∏è Llamadas meteorol√≥gicas: ${current + 1}/${CACHE_CONFIG.MAX_WEATHER_CALLS_PER_DAY}`);
            }
        }

        const cacheManager = new CacheManager();

        // Funci√≥n para limpiar cach√©
        function clearSessionCache() {
            console.log('üßπ Limpiando cach√© de sesi√≥n...');
            
            const keysToRemove = [];
            for (let i = 0; i < sessionStorage.length; i++) {
                const key = sessionStorage.key(i);
                if (key && (key.startsWith('weather_') || key.startsWith('cache_'))) {
                    keysToRemove.push(key);
                }
            }
            
            keysToRemove.forEach(key => sessionStorage.removeItem(key));
            
            // Recargar datos meteorol√≥gicos autom√°ticamente
            setTimeout(() => {
                console.log('üîÑ Recargando datos meteorol√≥gicos despu√©s de limpiar cach√©...');
                loadWeatherData();
            }, 500);
            
            alert('‚úÖ Cach√© limpiado correctamente. Los datos se actualizar√°n autom√°ticamente.');
        }

        // Funci√≥n para refrescar datos meteorol√≥gicos
        function refreshWeatherData() {
            console.log('üîÑ Refrescando datos meteorol√≥gicos...');
            loadWeatherData();
        }

        // Funci√≥n para generar datos meteorol√≥gicos de 24 horas completas
        function generateFullDayWeatherData(apiData) {
            console.log('üìä Usando datos directos de la API:', apiData.source);
            
            // Si Open-Meteo tiene datos de 24 horas, usarlos directamente
            if (apiData.source === 'Open-Meteo' && apiData.labels.length >= 20) {
                const now = new Date();
                const currentHour = now.getHours();
                
                // Generar etiquetas de 24 horas
                const labels = [];
                for (let i = 0; i < 24; i++) {
                    labels.push(`${i.toString().padStart(2, '0')}:00`);
                }
                
                // Usar directamente los datos de la API (son por horas)
                const temperatures = apiData.temperatures.slice(0, 24);
                const humidity = apiData.humidity.slice(0, 24);
                const precipitation = apiData.precipitation.slice(0, 24);
                
                // Completar hasta 24 si es necesario
                while (temperatures.length < 24) {
                    temperatures.push(temperatures[temperatures.length - 1]);
                    humidity.push(humidity[humidity.length - 1]);
                    precipitation.push(precipitation[precipitation.length - 1]);
                }
                
                return {
                    labels,
                    temperatures,
                    humidity,
                    precipitation,
                    currentHour,
                    source: apiData.source
                };
            }
            
            // Para OpenWeatherMap (datos cada 3 horas), usar directamente sin interpolar
            if (apiData.source === 'OpenWeatherMap') {
                const now = new Date();
                const currentHour = now.getHours();
                
                return {
                    labels: apiData.labels,
                    temperatures: apiData.temperatures,
                    humidity: apiData.humidity,
                    precipitation: apiData.precipitation,
                    currentHour,
                    source: apiData.source
                };
            }
            
            // Fallback para otros casos
            return {
                labels: apiData.labels,
                temperatures: apiData.temperatures,
                humidity: apiData.humidity,
                precipitation: apiData.precipitation,
                currentHour: new Date().getHours(),
                source: apiData.source
            };
        }

        // Funci√≥n para renderizar el gr√°fico meteorol√≥gico
        function renderWeatherChart(ctx, data) {
            if (weatherChart) {
                weatherChart.destroy();
            }

            // Generar datos para 24 horas completas
            const fullDayData = generateFullDayWeatherData(data);
            const currentHour = new Date().getHours();
            
            // Separar datos en pasado y futuro CON CONTINUIDAD
            const pastTemperatures = [];
            const futureTemperatures = [];
            const pastHumidity = [];
            const futureHumidity = [];
            const pastPrecipitation = [];
            const futurePrecipitation = [];
            
            fullDayData.labels.forEach((label, index) => {
                const hour = parseInt(label.split(':')[0]);
                
                if (hour <= currentHour) {
                    // Datos del pasado y presente
                    pastTemperatures.push(fullDayData.temperatures[index]);
                    pastHumidity.push(fullDayData.humidity[index]);
                    pastPrecipitation.push(fullDayData.precipitation[index]);
                    
                    // Para futuro: solo mostrar el punto actual (√∫ltimo del pasado) para crear continuidad
                    if (hour === currentHour) {
                        futureTemperatures.push(fullDayData.temperatures[index]);
                        futureHumidity.push(fullDayData.humidity[index]);
                        futurePrecipitation.push(fullDayData.precipitation[index]);
                    } else {
                        futureTemperatures.push(null);
                        futureHumidity.push(null);
                        futurePrecipitation.push(null);
                    }
                } else {
                    // Datos del futuro
                    pastTemperatures.push(null);
                    pastHumidity.push(null);
                    pastPrecipitation.push(null);
                    
                    futureTemperatures.push(fullDayData.temperatures[index]);
                    futureHumidity.push(fullDayData.humidity[index]);
                    futurePrecipitation.push(fullDayData.precipitation[index]);
                }
            });

            const datasets = [
                {
                    label: "Temperatura Registrada (¬∞C)",
                    data: pastTemperatures,
                    borderColor: "#2c3e50",
                    backgroundColor: "rgba(44, 62, 80, 0.1)",
                    fill: false,
                    tension: 0.3,
                    hidden: false,
                    borderWidth: 3,
                    pointBackgroundColor: "#2c3e50",
                    pointBorderColor: "#ffffff",
                    pointBorderWidth: 2,
                    pointRadius: 4
                },
                {
                    label: "Temperatura Prevista (¬∞C)",
                    data: futureTemperatures,
                    borderColor: "#3498db",
                    backgroundColor: "rgba(52, 152, 219, 0.1)",
                    fill: false,
                    tension: 0.3,
                    hidden: false,
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointBackgroundColor: "#3498db",
                    pointBorderColor: "#ffffff",
                    pointBorderWidth: 2,
                    pointRadius: 3
                },
                {
                    label: "Humedad Registrada (%)",
                    data: pastHumidity,
                    borderColor: "#27ae60",
                    backgroundColor: "rgba(39, 174, 96, 0.1)",
                    fill: false,
                    tension: 0.3,
                    hidden: true,
                    borderWidth: 3,
                    pointBackgroundColor: "#27ae60",
                    pointRadius: 3
                },
                {
                    label: "Humedad Prevista (%)",
                    data: futureHumidity,
                    borderColor: "#2ecc71",
                    backgroundColor: "rgba(46, 204, 113, 0.1)",
                    fill: false,
                    tension: 0.3,
                    hidden: true,
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointBackgroundColor: "#2ecc71",
                    pointRadius: 2
                },
                {
                    label: "Precipitaciones Registradas (%)",
                    data: pastPrecipitation,
                    borderColor: "#e74c3c",
                    backgroundColor: "rgba(231, 76, 60, 0.1)",
                    fill: false,
                    tension: 0.3,
                    hidden: true,
                    borderWidth: 3,
                    pointBackgroundColor: "#e74c3c",
                    pointRadius: 3
                },
                {
                    label: "Precipitaciones Previstas (%)",
                    data: futurePrecipitation,
                    borderColor: "#c0392b",
                    backgroundColor: "rgba(192, 57, 43, 0.1)",
                    fill: false,
                    tension: 0.3,
                    hidden: true,
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointBackgroundColor: "#c0392b",
                    pointRadius: 2
                }
            ];

            weatherChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: fullDayData.labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: "Hora del D√≠a (24h)"
                            },
                            grid: {
                                display: true,
                                color: 'rgba(0,0,0,0.1)'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: "Valores"
                            },
                            grid: {
                                display: true,
                                color: 'rgba(0,0,0,0.1)'
                            }
                        }
                    },
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const index = context[0].dataIndex;
                                    const hour = fullDayData.labels[index];
                                    let status = '';
                                    if (index === currentHour) status = ' (üî¥ ACTUAL)';
                                    else if (index < currentHour) status = ' (üìä Registrado)';
                                    else status = ' (üîÆ Pron√≥stico)';
                                    return hour + status;
                                },
                                label: function(context) {
                                    const label = context.dataset.label;
                                    const value = Math.round(context.parsed.y);
                                    if (label.includes('Temperatura')) return `${label}: ${value}¬∞C`;
                                    if (label.includes('Humedad')) return `${label}: ${value}%`;
                                    if (label.includes('Precipitaci√≥n')) return `${label}: ${value}%`;
                                    return `${label}: ${value}`;
                                }
                            }
                        }
                    },
                    elements: {
                        point: {
                            hoverRadius: 6
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                },
                plugins: [{
                    id: 'currentTimeLine',
                    afterDraw: function(chart) {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const currentHour = new Date().getHours();
                        
                        // Encontrar el √≠ndice de la hora actual
                        let currentIndex = -1;
                        if (fullDayData.source === 'Open-Meteo') {
                            currentIndex = currentHour;
                        } else {
                            // Para OpenWeatherMap, calcular basado en los labels
                            const now = new Date();
                            const currentTime = now.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
                            currentIndex = fullDayData.labels.findIndex(label => {
                                const labelHour = parseInt(label.split(':')[0]);
                                const currentHourInt = parseInt(currentTime.split(':')[0]);
                                return Math.abs(labelHour - currentHourInt) <= 1;
                            });
                        }
                        
                        if (currentIndex >= 0 && currentIndex < fullDayData.labels.length) {
                            const x = chart.scales.x.getPixelForValue(currentIndex);
                            
                            // Dibujar l√≠nea vertical roja
                            ctx.save();
                            ctx.strokeStyle = '#e74c3c';
                            ctx.lineWidth = 3;
                            ctx.setLineDash([5, 5]);
                            ctx.beginPath();
                            ctx.moveTo(x, chartArea.top);
                            ctx.lineTo(x, chartArea.bottom);
                            ctx.stroke();
                            
                            // Agregar etiqueta "AHORA"
                            ctx.fillStyle = '#e74c3c';
                            ctx.font = 'bold 12px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('üî¥ AHORA', x, chartArea.top - 10);
                            ctx.restore();
                        }
                    }
                }]
            });
        }

        // Configurar controles del gr√°fico meteorol√≥gico
        function setupWeatherControls() {
            const controlIds = ['temp-checkbox', 'humidity-checkbox', 'precipitation-checkbox'];
            const labelIds = ['temp-label', 'humidity-label', 'precipitation-label'];

            function updateVisibility(activeMetric) {
                if (!weatherChart) return;
                
                for (let i = 0; i < 6; i++) {
                    const datasetMeta = weatherChart.getDatasetMeta(i);
                    if (datasetMeta) {
                        switch (activeMetric) {
                            case 0: // Temperatura
                                datasetMeta.hidden = !(i === 0 || i === 1);
                                break;
                            case 1: // Humedad
                                datasetMeta.hidden = !(i === 2 || i === 3);
                                break;
                            case 2: // Precipitaciones
                                datasetMeta.hidden = !(i === 4 || i === 5);
                                break;
                            default:
                                datasetMeta.hidden = true;
                        }
                    }
                }
                
                labelIds.forEach((labelId, index) => {
                    const label = document.getElementById(labelId);
                    if (label) {
                        if (index === activeMetric) {
                            label.classList.add('active');
                        } else {
                            label.classList.remove('active');
                        }
                    }
                });
                
                weatherChart.update();
            }

            controlIds.forEach((id, index) => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.addEventListener('change', function() {
                        if (this.checked) {
                            controlIds.forEach((otherId, otherIndex) => {
                                if (otherIndex !== index) {
                                    const otherCheckbox = document.getElementById(otherId);
                                    if (otherCheckbox) otherCheckbox.checked = false;
                                }
                            });
                            updateVisibility(index);
                        } else {
                            updateVisibility(0);
                            const tempCheckbox = document.getElementById('temp-checkbox');
                            if (tempCheckbox) tempCheckbox.checked = true;
                        }
                    });
                }
            });

            setTimeout(() => {
                const tempCheckbox = document.getElementById('temp-checkbox');
                if (tempCheckbox) {
                    tempCheckbox.checked = true;
                    updateVisibility(0);
                }
            }, 100);
        }

        // ===== SISTEMA DE RECOMENDACIONES DE AHORRO ENERG√âTICO =====

        // Funci√≥n principal para generar todas las recomendaciones
        function generateEnergyRecommendations(weatherData) {
            if (!weatherData || !weatherData.temperatures) return;

            console.log('üí° Generando recomendaciones de ahorro energ√©tico...');
            
            const fullDayData = generateFullDayWeatherData(weatherData);
            const currentHour = new Date().getHours();
            
            // Analizar datos meteorol√≥gicos
            const analysis = analyzeWeatherConditions(fullDayData, currentHour);
            
            // Generar alertas importantes
            generateEnergyAlerts(analysis);
            
            // Generar recomendaciones para el d√≠a
            generateDailyRecommendations(analysis);
            
            // Generar recomendaciones por franjas horarias
            generateHourlyRecommendations(fullDayData, currentHour);
        }

        // Analizar condiciones meteorol√≥gicas para determinar estrategias de ahorro
        function analyzeWeatherConditions(fullDayData, currentHour) {
            const temps = fullDayData.temperatures;
            const humidity = fullDayData.humidity;
            const precipitation = fullDayData.precipitation;
            
            const currentTemp = temps[currentHour] || temps[0];
            const currentHumidity = humidity[currentHour] || humidity[0];
            const currentPrecip = precipitation[currentHour] || precipitation[0];
            
            // Calcular temperaturas del d√≠a
            const minTemp = Math.min(...temps.filter(t => t !== undefined));
            const maxTemp = Math.max(...temps.filter(t => t !== undefined));
            const avgTemp = temps.reduce((sum, t) => sum + (t || 0), 0) / temps.length;
            
            // Detectar tendencias
            const tempTrend = detectTemperatureTrend(temps, currentHour);
            const comfortZone = currentTemp >= 18 && currentTemp <= 25;
            
            // Detectar condiciones especiales
            const heatWave = maxTemp > 35;
            const coldWave = minTemp < 5;
            const highHumidity = currentHumidity > 70;
            const lowHumidity = currentHumidity < 30;
            const rainExpected = precipitation.some(p => p > 50);
            
            return {
                current: { temp: currentTemp, humidity: currentHumidity, precipitation: currentPrecip },
                daily: { minTemp, maxTemp, avgTemp },
                trends: { tempTrend, comfortZone },
                conditions: { heatWave, coldWave, highHumidity, lowHumidity, rainExpected },
                fullData: fullDayData
            };
        }

        // Detectar tendencia de temperatura
        function detectTemperatureTrend(temps, currentHour) {
            if (currentHour >= temps.length - 3) return 'stable';
            
            const nextHours = temps.slice(currentHour, currentHour + 3);
            const currentTemp = temps[currentHour];
            
            if (nextHours.every(t => t > currentTemp + 1)) return 'rising';
            if (nextHours.every(t => t < currentTemp - 1)) return 'falling';
            return 'stable';
        }

        // Generar alertas importantes
        function generateEnergyAlerts(analysis) {
            const alertsContainer = document.getElementById('alertas-energia');
            if (!alertsContainer) return;

            const alerts = [];
            
            // Alerta de ola de calor
            if (analysis.conditions.heatWave) {
                alerts.push({
                    type: 'critica',
                    icon: 'üî•',
                    title: 'Alerta: Ola de Calor',
                    message: `Temperatura m√°xima de ${analysis.daily.maxTemp}¬∞C. Prepara sistemas de refrigeraci√≥n eficientes y considera desplazar actividades que generen calor.`
                });
            }
            
            // Alerta de ola de fr√≠o
            if (analysis.conditions.coldWave) {
                alerts.push({
                    type: 'critica',
                    icon: 'ü•∂',
                    title: 'Alerta: Ola de Fr√≠o',
                    message: `Temperatura m√≠nima de ${analysis.daily.minTemp}¬∞C. Revisa el aislamiento de tu hogar y programa la calefacci√≥n de manera eficiente.`
                });
            }
            
            // Alerta de cambio brusco de temperatura
            if (analysis.daily.maxTemp - analysis.daily.minTemp > 15) {
                alerts.push({
                    type: 'advertencia',
                    icon: 'üå°Ô∏è',
                    title: 'Cambio T√©rmico Pronunciado',
                    message: `Variaci√≥n de ${(analysis.daily.maxTemp - analysis.daily.minTemp).toFixed(1)}¬∞C en el d√≠a. Ajusta termostatos gradualmente para mayor eficiencia.`
                });
            }
            
            // Alerta de humedad alta
            if (analysis.conditions.highHumidity) {
                alerts.push({
                    type: 'info',
                    icon: 'üíß',
                    title: 'Humedad Elevada',
                    message: `Humedad del ${analysis.current.humidity}%. Usa deshumidificadores y evita generar vapor adicional (duchas largas, cocinar con ollas abiertas).`
                });
            }
            
            // Alerta de condiciones ideales
            if (analysis.trends.comfortZone && !analysis.conditions.heatWave && !analysis.conditions.coldWave) {
                alerts.push({
                    type: 'positiva',
                    icon: '‚ú®',
                    title: 'Condiciones Ideales',
                    message: `Temperatura confortable de ${analysis.current.temp}¬∞C. Perfecto para minimizar uso de calefacci√≥n/refrigeraci√≥n y maximizar ventilaci√≥n natural.`
                });
            }

            // Renderizar alertas
            alertsContainer.innerHTML = alerts.map(alert => `
                <div class="alerta ${alert.type}">
                    <div style="font-size: 1.5em;">${alert.icon}</div>
                    <div>
                        <div style="font-weight: bold; margin-bottom: 5px;">${alert.title}</div>
                        <div>${alert.message}</div>
                    </div>
                </div>
            `).join('');
        }

        // Funci√≥n para obtener datos meteorol√≥gicos reales
        async function fetchRealWeatherData() {
            if (!cacheManager.canMakeWeatherCall()) {
                throw new Error('L√≠mite de llamadas meteorol√≥gicas alcanzado');
            }

            const apis = [
                // OpenWeatherMap con clave de usuario
                async () => {
                    const API_KEY = '2e7c789fef35b1b26b35c17e0eccc5dd';
                    if (!API_KEY) throw new Error('No API key for OpenWeatherMap');
                    
                    const url = `https://api.openweathermap.org/data/2.5/forecast?lat=${currentLocation.lat}&lon=${currentLocation.lon}&appid=${API_KEY}&units=metric&lang=es`;
                    console.log('üå§Ô∏è Intentando OpenWeatherMap...');
                    
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`OpenWeatherMap error: ${response.status}`);
                    
                    const data = await response.json();
                    return processOpenWeatherMapForecastData(data);
                },
                
                // Open-Meteo
                async () => {
                    const url = `https://api.open-meteo.com/v1/forecast?latitude=${currentLocation.lat}&longitude=${currentLocation.lon}&hourly=temperature_2m,relative_humidity_2m,precipitation_probability&timezone=Europe/Madrid&forecast_days=1`;
                    console.log('üå§Ô∏è Intentando Open-Meteo...');
                    
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`Open-Meteo error: ${response.status}`);
                    
                    const data = await response.json();
                    return processOpenMeteoData(data);
                }
            ];

            // Intentar cada API
            for (const apiCall of apis) {
                try {
                    const result = await apiCall();
                    cacheManager.incrementWeatherCallCounter();
                    return result;
                } catch (error) {
                    console.warn('API fall√≥:', error.message);
                }
            }

            throw new Error('Todas las APIs meteorol√≥gicas fallaron');
        }

        // Procesar datos de OpenWeatherMap Forecast
        function processOpenWeatherMapForecastData(data) {
            console.log('‚úÖ Datos de OpenWeatherMap Forecast procesados exitosamente');
            
            const current = data.list[0];
            const labels = [];
            const temperatures = [];
            const humidity = [];
            const precipitation = [];

            // Tomar m√°s elementos para cubrir mejor las 24 horas (cada 3 horas)
            for (let i = 0; i < Math.min(12, data.list.length); i++) {
                const item = data.list[i];
                const date = new Date(item.dt * 1000);
                labels.push(date.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' }));
                temperatures.push(Math.round(item.main.temp));
                humidity.push(Math.round(item.main.humidity));
                precipitation.push(Math.round(item.pop * 100)); // Probabilidad de precipitaci√≥n
            }

            return {
                labels,
                temperatures,
                humidity,
                precipitation,
                current: {
                    temp: Math.round(current.main.temp),
                    humidity: Math.round(current.main.humidity),
                    precipitation: Math.round(current.pop * 100)
                },
                source: 'OpenWeatherMap'
            };
        }

        // Procesar datos de Open-Meteo
        function processOpenMeteoData(data) {
            console.log('‚úÖ Datos de Open-Meteo procesados exitosamente');
            
            const hourly = data.hourly;
            const labels = [];
            const temperatures = [];
            const humidity = [];
            const precipitation = [];

            // Tomar todas las 24 horas disponibles
            for (let i = 0; i < Math.min(24, hourly.time.length); i++) {
                const date = new Date(hourly.time[i]);
                labels.push(date.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' }));
                temperatures.push(Math.round(hourly.temperature_2m[i]));
                humidity.push(Math.round(hourly.relative_humidity_2m[i]));
                precipitation.push(Math.round(hourly.precipitation_probability[i] || 0));
            }

            return {
                labels,
                temperatures,
                humidity,
                precipitation,
                current: {
                    temp: Math.round(hourly.temperature_2m[0]),
                    humidity: Math.round(hourly.relative_humidity_2m[0]),
                    precipitation: Math.round(hourly.precipitation_probability[0] || 0)
                },
                source: 'Open-Meteo'
            };
        }

        // Generar datos meteorol√≥gicos simulados espec√≠ficos para Madrid
        function generateMadridSpecificWeatherData() {
            const now = new Date();
            const hour = now.getHours();
            const season = getSeason();
            
            // Temperaturas base seg√∫n estaci√≥n y hora
            let baseTemp = 15;
            if (season === 'verano') baseTemp = 28;
            else if (season === 'invierno') baseTemp = 8;
            else if (season === 'primavera') baseTemp = 18;
            else baseTemp = 12; // oto√±o

            // Ajustar seg√∫n hora del d√≠a actual
            if (hour >= 6 && hour <= 12) baseTemp += 2;
            else if (hour >= 13 && hour <= 16) baseTemp += 5;
            else if (hour >= 17 && hour <= 20) baseTemp += 2;
            else baseTemp -= 3;

            const labels = [];
            const temperatures = [];
            const humidity = [];
            const precipitation = [];

            // Temperatura inicial con peque√±a variaci√≥n
            let currentTemp = baseTemp + (Math.random() - 0.5) * 2;

            for (let i = 0; i < 8; i++) {
                const futureHour = (hour + i * 3) % 24;
                labels.push(`${futureHour.toString().padStart(2, '0')}:00`);
                
                // Calcular temperatura realista basada en la hora del d√≠a
                let hourlyTempBase = baseTemp;
                if (futureHour >= 6 && futureHour <= 12) hourlyTempBase += 2;
                else if (futureHour >= 13 && futureHour <= 16) hourlyTempBase += 5;
                else if (futureHour >= 17 && futureHour <= 20) hourlyTempBase += 2;
                else hourlyTempBase -= 3;

                // Aplicar cambio gradual (m√°ximo ¬±1.5¬∞C por hora)
                const maxChange = 1.5;
                const targetTemp = hourlyTempBase + (Math.random() - 0.5) * 2;
                const tempDiff = targetTemp - currentTemp;
                const actualChange = Math.sign(tempDiff) * Math.min(Math.abs(tempDiff), maxChange);
                
                currentTemp += actualChange;
                temperatures.push(Math.round(currentTemp * 10) / 10); // Redondear a 1 decimal
                
                const baseHumidity = season === 'invierno' ? 70 : 50;
                humidity.push(Math.round(baseHumidity + (Math.random() - 0.5) * 20));
                
                const basePrecip = season === 'verano' ? 10 : 30;
                precipitation.push(Math.round(Math.max(0, basePrecip + (Math.random() - 0.5) * 40)));
            }

            return {
                labels,
                temperatures,
                humidity,
                precipitation,
                current: {
                    temp: temperatures[0],
                    humidity: humidity[0],
                    precipitation: precipitation[0]
                },
                source: 'Simulaci√≥n Madrid'
            };
        }

        // Obtener estaci√≥n del a√±o
        function getSeason() {
            const month = new Date().getMonth() + 1;
            if (month >= 6 && month <= 8) return 'verano';
            if (month >= 12 || month <= 2) return 'invierno';
            if (month >= 3 && month <= 5) return 'primavera';
            return 'oto√±o';
        }

        // Actualizar visualizaci√≥n meteorol√≥gica
        function updateWeatherDisplay(weatherElement, data) {
            if (!weatherElement || !data) return;

            const currentTemp = data.current ? data.current.temp : data.temperatures[0];
            const currentHumidity = data.current ? data.current.humidity : data.humidity[0];
            const currentPrecip = data.current ? data.current.precipitation : data.precipitation[0];

            weatherElement.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                    <div style="background: linear-gradient(135deg, #ff7675, #fd79a8); padding: 15px; border-radius: 10px; color: white; text-align: center;">
                        <div id="temp-display" style="font-size: 2rem; font-weight: bold;">${currentTemp}¬∞C</div>
                        <div style="opacity: 0.9;">üå°Ô∏è Temperatura</div>
                    </div>
                    <div style="background: linear-gradient(135deg, #74b9ff, #0984e3); padding: 15px; border-radius: 10px; color: white; text-align: center;">
                        <div id="humidity-display" style="font-size: 2rem; font-weight: bold;">${currentHumidity}%</div>
                        <div style="opacity: 0.9;">üíß Humedad</div>
                    </div>
                    <div style="background: linear-gradient(135deg, #a29bfe, #6c5ce7); padding: 15px; border-radius: 10px; color: white; text-align: center;">
                        <div id="precip-display" style="font-size: 2rem; font-weight: bold;">${currentPrecip}%</div>
                        <div style="opacity: 0.9;">üåßÔ∏è Precipitaci√≥n</div>
                    </div>
                </div>
                <div style="text-align: center; color: #7f8c8d; font-size: 0.9rem; margin-top: 10px;">
                    üìç <strong>${currentLocation.name}</strong> | üïí ${new Date().toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' })}
                </div>
            `;
        }

        // Funci√≥n para actualizar solo los valores del display (sincronizado con gr√°fica)
        function updateWeatherDisplayWithSyncedData(weatherElement, syncedData) {
            const tempDisplay = document.getElementById('temp-display');
            const humidityDisplay = document.getElementById('humidity-display');
            const precipDisplay = document.getElementById('precip-display');
            
            if (tempDisplay && syncedData.temp !== undefined) {
                tempDisplay.textContent = `${syncedData.temp}¬∞C`;
            }
            if (humidityDisplay && syncedData.humidity !== undefined) {
                humidityDisplay.textContent = `${syncedData.humidity}%`;
            }
            if (precipDisplay && syncedData.precipitation !== undefined) {
                precipDisplay.textContent = `${syncedData.precipitation}%`;
            }
        }

        // Cargar datos meteorol√≥gicos
        async function loadWeatherData() {
            const weatherElement = document.getElementById("weather");
            const weatherCtx = document.getElementById("weather-chart").getContext("2d");

            try {
                showLoading("weather");
                
                // Intentar detectar ubicaci√≥n del usuario primero
                const locationDetected = await detectUserLocation();
                
                if (!locationDetected) {
                    console.log('üèôÔ∏è Configurando Madrid como ubicaci√≥n por defecto');
                    currentLocation = {
                        name: 'Madrid',
                        lat: 40.4168,
                        lon: -3.7038,
                        country: 'Espa√±a',
                        detected: false
                    };
                }
                
                console.log(`üå§Ô∏è Cargando datos meteorol√≥gicos para ${currentLocation.name}...`);
                
                let weatherData = null;
                let dataSource = '';
                
                try {
                    weatherData = await fetchRealWeatherData();
                    dataSource = 'Datos reales obtenidos desde API';
                    console.log('‚úÖ Datos meteorol√≥gicos reales cargados exitosamente');
                } catch (apiError) {
                    console.warn('‚ö†Ô∏è Error al obtener datos reales:', apiError.message);
                    console.log('üé≤ Generando datos simulados para Madrid...');
                    weatherData = generateMadridSpecificWeatherData();
                    dataSource = 'Datos simulados espec√≠ficos para Madrid (API no disponible)';
                }
                
                updateWeatherDisplay(weatherElement, weatherData);
                
                // Generar datos para la gr√°fica
                const fullDayData = generateFullDayWeatherData(weatherData);
                
                // Actualizar el display con la temperatura actual de la gr√°fica
                const currentHour = new Date().getHours();
                let currentTemp, currentHumidity, currentPrecip;
                
                if (fullDayData.source === 'Open-Meteo' && fullDayData.temperatures.length >= 24) {
                    // Para Open-Meteo, usar directamente la hora actual
                    currentTemp = fullDayData.temperatures[currentHour];
                    currentHumidity = fullDayData.humidity[currentHour];
                    currentPrecip = fullDayData.precipitation[currentHour];
                } else {
                    // Para OpenWeatherMap o otros, encontrar el dato m√°s cercano a la hora actual
                    let closestIndex = 0;
                    let minDiff = Number.MAX_VALUE;
                    
                    for (let i = 0; i < fullDayData.labels.length; i++) {
                        const labelHour = parseInt(fullDayData.labels[i].split(':')[0]);
                        const diff = Math.abs(labelHour - currentHour);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestIndex = i;
                        }
                    }
                    
                    currentTemp = fullDayData.temperatures[closestIndex];
                    currentHumidity = fullDayData.humidity[closestIndex];
                    currentPrecip = fullDayData.precipitation[closestIndex];
                }
                
                // Actualizar el display con los datos sincronizados con la gr√°fica
                updateWeatherDisplayWithSyncedData(weatherElement, {
                    temp: currentTemp,
                    humidity: currentHumidity,
                    precipitation: currentPrecip
                });
                
                renderWeatherChart(weatherCtx, weatherData);
                setupWeatherControls();
                
                const sourceIndicator = weatherElement.querySelector('.weather-source') || 
                                       document.createElement('div');
                sourceIndicator.className = 'weather-source';
                sourceIndicator.style.cssText = 'font-size: 0.8em; color: #666; margin-top: 5px; text-align: center;';
                sourceIndicator.textContent = `üìä ${dataSource}`;
                
                if (!weatherElement.querySelector('.weather-source')) {
                    weatherElement.appendChild(sourceIndicator);
                }
                
                hideLoading("weather");
                
                // Actualizar status de ubicaci√≥n
                updateLocationStatus();
                
                // Generar recomendaciones de ahorro energ√©tico
                generateEnergyRecommendations(weatherData);

            } catch (err) {
                hideLoading("weather");
                console.error("Error cr√≠tico en carga meteorol√≥gica:", err);
                
                // Actualizar status con error
                updateLocationStatus('‚ùå Error cargando datos meteorol√≥gicos');
                
                const emergencyData = generateMadridSpecificWeatherData();
                updateWeatherDisplay(weatherElement, emergencyData);
                
                // Sincronizar con los datos de la gr√°fica tambi√©n para emergencia
                const fullDayEmergencyData = generateFullDayWeatherData(emergencyData);
                const currentHour = new Date().getHours();
                
                updateWeatherDisplayWithSyncedData(weatherElement, {
                    temp: fullDayEmergencyData.temperatures[currentHour] || emergencyData.temperatures[0],
                    humidity: fullDayEmergencyData.humidity[currentHour] || emergencyData.humidity[0],
                    precipitation: fullDayEmergencyData.precipitation[currentHour] || emergencyData.precipitation[0]
                });
                
                renderWeatherChart(weatherCtx, emergencyData);
                setupWeatherControls();
                
                // Generar recomendaciones incluso con datos de emergencia
                generateEnergyRecommendations(emergencyData);
                
                weatherElement.innerHTML += "<br><div style='color: #e74c3c; font-size: 0.8em; text-align: center; margin-top: 5px;'>‚ö†Ô∏è Datos meteorol√≥gicos de emergencia</div>";
            }
        }

        // Funciones de utilidad
        function showLoading(id) {
            const element = document.getElementById(id);
            if (element) {
                element.style.opacity = '0.6';
                element.style.pointerEvents = 'none';
            }
        }

        function hideLoading(id) {
            const element = document.getElementById(id);
            if (element) {
                element.style.opacity = '1';
                element.style.pointerEvents = 'auto';
            }
        }

        // ===== FUNCIONALIDAD DEL MAPA =====

        function initMap() {
            // Configuraci√≥n del mapa centrado en Espa√±a
            map = L.map('map').setView([currentLocation.lat, currentLocation.lon], 6);

            // Capa de mapa
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 18
            }).addTo(map);

            // L√≠mites de Espa√±a (aproximados)
            const spainBounds = [
                [35.0, -10.0], // Suroeste (incluye Canarias)
                [44.0, 5.0]    // Noreste
            ];
            
            // Rect√°ngulo para mostrar el √°rea de cobertura
            const spainRectangle = L.rectangle(spainBounds, {
                color: '#3498db',
                weight: 2,
                fillOpacity: 0.1
            }).addTo(map);

            // Marcador inicial en la ubicaci√≥n actual
            updateMapMarker();

            // Event listener para DOBLE CLICKS en el mapa
            map.on('dblclick', function(e) {
                const lat = e.latlng.lat;
                const lng = e.latlng.lng;
                
                // Verificar si est√° dentro de Espa√±a
                if (lat >= 35.0 && lat <= 44.0 && lng >= -10.0 && lng <= 5.0) {
                    console.log(`üñ±Ô∏è Doble click detectado en: ${lat}, ${lng}`);
                    updateLocationFromCoordinates(lat, lng);
                } else {
                    alert('‚ö†Ô∏è Por favor, selecciona una ubicaci√≥n dentro del territorio espa√±ol.');
                }
            });
            
            // Mostrar tooltip informativo
            const infoControl = L.control({position: 'topright'});
            infoControl.onAdd = function(map) {
                const div = L.DomUtil.create('div', 'leaflet-control-custom');
                div.innerHTML = '<div style="background: rgba(255,255,255,0.9); padding: 8px; border-radius: 5px; border: 1px solid #ccc; font-size: 12px;"><strong>üí° Tip:</strong><br>Doble click en cualquier punto<br>del mapa para cambiar<br>la ubicaci√≥n meteorol√≥gica</div>';
                return div;
            };
            infoControl.addTo(map);
        }

        function updateMapMarker() {
            if (currentMarker) {
                map.removeLayer(currentMarker);
            }

            // Crear marcador con popup informativo
            currentMarker = L.marker([currentLocation.lat, currentLocation.lon])
                .addTo(map)
                .bindPopup(`
                    <div style="text-align: center;">
                        <strong>üìç ${currentLocation.name}</strong><br>
                        <small>Lat: ${currentLocation.lat.toFixed(4)}, Lon: ${currentLocation.lon.toFixed(4)}</small><br>
                        <small>${currentLocation.detected ? 'üéØ Ubicaci√≥n detectada' : 'üñ±Ô∏è Ubicaci√≥n seleccionada'}</small>
                    </div>
                `);

            map.setView([currentLocation.lat, currentLocation.lon], 8);
            
            // Actualizar status en la interfaz
            updateLocationStatus();
        }

        async function updateLocationFromCoordinates(lat, lon) {
            // Mostrar loading
            updateLocationStatus('üîÑ Obteniendo informaci√≥n de la ubicaci√≥n...');
            
            try {
                // Obtener nombre de la ciudad
                const cityName = await getCityName(lat, lon);
                
                currentLocation = {
                    name: cityName,
                    lat: lat,
                    lon: lon,
                    country: 'Espa√±a',
                    detected: false
                };

                updateMapMarker();
                
                // Recargar datos meteorol√≥gicos para la nueva ubicaci√≥n
                console.log(`üå§Ô∏è Cargando datos meteorol√≥gicos para ${cityName}...`);
                await loadWeatherData();
                
            } catch (error) {
                console.error('Error actualizando ubicaci√≥n:', error);
                updateLocationStatus('‚ùå Error obteniendo informaci√≥n de la ubicaci√≥n');
            }
        }
        
        // Funci√≥n para actualizar el status de ubicaci√≥n en la interfaz
        function updateLocationStatus(message = null) {
            const statusElement = document.getElementById('location-status');
            if (statusElement) {
                if (message) {
                    statusElement.textContent = message;
                } else {
                    const icon = currentLocation.detected ? 'üéØ' : 'üñ±Ô∏è';
                    const method = currentLocation.detected ? 'Detectada autom√°ticamente' : 'Seleccionada manualmente';
                    statusElement.innerHTML = `${icon} <strong>${currentLocation.name}</strong> - ${method}`;
                }
            }
        }

        // Generar recomendaciones para todo el d√≠a
        function generateDailyRecommendations(analysis) {
            const consejosContainer = document.getElementById('consejos-dia');
            if (!consejosContainer) return;

            const recommendations = [];
            
            // Recomendaciones de calefacci√≥n/refrigeraci√≥n
            if (analysis.daily.avgTemp < 16) {
                recommendations.push({
                    type: 'calefaccion',
                    icon: 'üî•',
                    title: 'Optimizaci√≥n de Calefacci√≥n',
                    description: `Temperatura media de ${analysis.daily.avgTemp.toFixed(1)}¬∞C. Programa calefacci√≥n a 19-21¬∞C, usa ropa de abrigo en casa y aprovecha la radiaci√≥n solar cerrando cortinas por la noche.`
                });
            } else if (analysis.daily.avgTemp > 26) {
                recommendations.push({
                    type: 'refrigeracion',
                    icon: '‚ùÑÔ∏è',
                    title: 'Refrigeraci√≥n Eficiente',
                    description: `Temperatura media de ${analysis.daily.avgTemp.toFixed(1)}¬∞C. Usa aire acondicionado a 24-26¬∞C, cierra persianas durante el d√≠a y aprovecha corrientes de aire nocturnas.`
                });
            } else {
                recommendations.push({
                    type: 'general',
                    icon: 'üåø',
                    title: 'Ventilaci√≥n Natural',
                    description: `Temperatura ideal de ${analysis.daily.avgTemp.toFixed(1)}¬∞C. Perfecto para ventilar naturalmente, abrir ventanas estrat√©gicamente y minimizar sistemas HVAC.`
                });
            }
            
            // Recomendaciones de humedad
            if (analysis.conditions.highHumidity) {
                recommendations.push({
                    type: 'ventilacion',
                    icon: 'üí®',
                    title: 'Control de Humedad',
                    description: `Humedad alta del ${analysis.current.humidity}%. Usa extractores en ba√±o y cocina, evita secar ropa en interior y considera un deshumidificador en horas pico.`
                });
            } else if (analysis.conditions.lowHumidity) {
                recommendations.push({
                    type: 'ventilacion',
                    icon: 'üíß',
                    title: 'Humidificaci√≥n Natural',
                    description: `Humedad baja del ${analysis.current.humidity}%. Coloca recipientes con agua, plantas h√∫medas o toallas mojadas para aumentar humedad sin gastar energ√≠a.`
                });
            }
            
            // Recomendaciones de iluminaci√≥n seg√∫n precipitaci√≥n
            if (analysis.conditions.rainExpected) {
                recommendations.push({
                    type: 'iluminacion',
                    icon: 'üí°',
                    title: 'Iluminaci√≥n en D√≠a Nublado',
                    description: 'Se espera lluvia. Usa luces LED en √°reas de trabajo, aprovecha luz natural cerca de ventanas y considera luces c√°lidas para ambientar sin sobreconsumo.'
                });
            } else {
                recommendations.push({
                    type: 'iluminacion',
                    icon: '‚òÄÔ∏è',
                    title: 'Aprovechamiento Solar',
                    description: 'D√≠a despejado. Maximiza luz natural, abre cortinas y persianas, apaga luces innecesarias y considera cargar dispositivos con energ√≠a solar si tienes paneles.'
                });
            }
            
            // Recomendaci√≥n especial seg√∫n tendencia
            if (analysis.trends.tempTrend === 'rising') {
                recommendations.push({
                    type: 'general',
                    icon: 'üìà',
                    title: 'Preparaci√≥n para Calor',
                    description: 'Temperatura en aumento. Pre-enfr√≠a la casa en horas frescas, cierra ventanas antes del mediod√≠a y prepara sistemas de refrigeraci√≥n para m√°s tarde.'
                });
            } else if (analysis.trends.tempTrend === 'falling') {
                recommendations.push({
                    type: 'general',
                    icon: 'üìâ',
                    title: 'Preparaci√≥n para Fr√≠o',
                    description: 'Temperatura en descenso. Aprovecha calor residual, programa calefacci√≥n gradual y considera cerrar habitaciones no utilizadas para concentrar calor.'
                });
            }

            // Renderizar recomendaciones
            consejosContainer.innerHTML = recommendations.map(rec => `
                <div class="consejo ${rec.type}">
                    <div class="consejo-titulo">
                        <span style="font-size: 1.2em;">${rec.icon}</span>
                        ${rec.title}
                    </div>
                    <div class="consejo-descripcion">${rec.description}</div>
                </div>
            `).join('');
        }

        // Generar recomendaciones por franjas horarias
        function generateHourlyRecommendations(fullDayData, currentHour) {
            const horasContainer = document.getElementById('consejos-horas');
            if (!horasContainer) return;

            const hourlyTips = [];
            const temps = fullDayData.temperatures;
            
            // Dividir el d√≠a en franjas de 6 horas
            const franjas = [
                { start: 0, end: 6, name: 'Madrugada (00-06h)', icon: 'üåô' },
                { start: 6, end: 12, name: 'Ma√±ana (06-12h)', icon: 'üåÖ' },
                { start: 12, end: 18, name: 'Tarde (12-18h)', icon: '‚òÄÔ∏è' },
                { start: 18, end: 24, name: 'Noche (18-24h)', icon: 'üåÜ' }
            ];
            
            franjas.forEach(franja => {
                const franjaTemps = temps.slice(franja.start, franja.end).filter(t => t !== undefined);
                if (franjaTemps.length === 0) return;
                
                const avgTemp = franjaTemps.reduce((sum, t) => sum + t, 0) / franjaTemps.length;
                const minTemp = Math.min(...franjaTemps);
                const maxTemp = Math.max(...franjaTemps);
                
                let consejo = '';
                let ahorro = '';
                
                // Generar consejo espec√≠fico para la franja
                if (franja.start === 0) { // Madrugada
                    if (avgTemp < 12) {
                        consejo = 'Temperatura baja. Reduce calefacci√≥n gradualmente, usa mantas adicionales y programa termostato inteligente.';
                        ahorro = 'Ahorro: 15-25%';
                    } else if (avgTemp > 25) {
                        consejo = 'Noche c√°lida. Aprovecha para ventilar, usa ventiladores en lugar de A/C si es posible.';
                        ahorro = 'Ahorro: 20-30%';
                    } else {
                        consejo = 'Temperatura ideal para descanso. Mant√©n sistemas en modo eco o apagados.';
                        ahorro = 'Ahorro: 30-40%';
                    }
                } else if (franja.start === 6) { // Ma√±ana
                    if (avgTemp < 15) {
                        consejo = 'Ma√±ana fresca. Programa calefacci√≥n 30min antes de levantarte, usa radiaci√≥n solar abriendo cortinas.';
                        ahorro = 'Ahorro: 10-20%';
                    } else {
                        consejo = 'Ma√±ana templada. Ventila para renovar aire, aprovecha luz natural y evita calefacci√≥n.';
                        ahorro = 'Ahorro: 25-35%';
                    }
                } else if (franja.start === 12) { // Tarde
                    if (avgTemp > 28) {
                        consejo = 'Tarde calurosa. Pre-enfr√≠a antes del pico de calor, cierra persianas, usa A/C eficientemente.';
                        ahorro = 'Ahorro: 15-25%';
                    } else if (avgTemp < 18) {
                        consejo = 'Tarde fresca. Aprovecha sol directo, abre cortinas al sur, programa calefacci√≥n gradual.';
                        ahorro = 'Ahorro: 20-30%';
                    } else {
                        consejo = 'Tarde perfecta. Ventilaci√≥n natural, sistemas HVAC al m√≠nimo o apagados.';
                        ahorro = 'Ahorro: 35-45%';
                    }
                } else { // Noche
                    if (avgTemp > 22) {
                        consejo = 'Noche c√°lida. Ventila cuando baje el sol, usa ventiladores, programa A/C en modo nocturno.';
                        ahorro = 'Ahorro: 20-30%';
                    } else if (avgTemp < 16) {
                        consejo = 'Noche fresca. Programa calefacci√≥n por temporizador, usa ropa de cama adicional.';
                        ahorro = 'Ahorro: 15-25%';
                    } else {
                        consejo = 'Noche agradable. Ideal para sistemas en standby, ventilaci√≥n natural ligera.';
                        ahorro = 'Ahorro: 30-40%';
                    }
                }
                
                // Marcar franja actual
                const isCurrent = currentHour >= franja.start && currentHour < franja.end;
                
                hourlyTips.push({
                    franja: franja.name,
                    icon: franja.icon,
                    temp: `${minTemp}¬∞-${maxTemp}¬∞C`,
                    consejo,
                    ahorro,
                    isCurrent
                });
            });

            // Renderizar franjas horarias
            horasContainer.innerHTML = hourlyTips.map(tip => `
                <div class="franja-horaria ${tip.isCurrent ? 'current-franja' : ''}" style="${tip.isCurrent ? 'border-left: 4px solid #e74c3c; background: linear-gradient(135deg, #fff5f5, #ffe6e6);' : ''}">
                    <div class="franja-hora">
                        ${tip.icon} ${tip.franja.split('(')[0]}
                        ${tip.isCurrent ? '<br><small style="color: #e74c3c; font-weight: normal;">üî¥ Actual</small>' : ''}
                    </div>
                    <div class="franja-consejo">
                        <strong>Temp: ${tip.temp}</strong><br>
                        ${tip.consejo}
                    </div>
                    <div class="franja-ahorro">${tip.ahorro}</div>
                </div>
            `).join('');
        }

        async function buscarCiudad() {
            const ciudad = document.getElementById('ciudad').value.trim();
            if (!ciudad) {
                alert('Por favor, introduce el nombre de una ciudad.');
                return;
            }

            try {
                showLoading('map');
                
                // Usar Nominatim (OpenStreetMap) para geocodificaci√≥n
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(ciudad)},Espa√±a&limit=1&countrycodes=es`);
                const data = await response.json();

                if (data.length > 0) {
                    const location = data[0];
                    currentLocation = {
                        name: location.display_name.split(',')[0],
                        lat: parseFloat(location.lat),
                        lon: parseFloat(location.lon),
                        country: 'Espa√±a',
                        detected: false
                    };

                    updateMapMarker();
                    loadWeatherData(); // Recargar datos meteorol√≥gicos
                    
                    alert(`Ubicaci√≥n encontrada: ${currentLocation.name}`);
                } else {
                    alert('No se encontr√≥ la ciudad. Intenta con otro nombre.');
                }
            } catch (error) {
                console.error('Error al buscar ciudad:', error);
                alert('Error al buscar la ciudad. Int√©ntalo de nuevo.');
            } finally {
                hideLoading('map');
            }
        }

        // Inicializaci√≥n cuando se carga la p√°gina
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üå§Ô∏è Iniciando p√°gina meteorol√≥gica...');
            
            // Agregar event listener para Enter en el campo de b√∫squeda
            const ciudadInput = document.getElementById('ciudad');
            if (ciudadInput) {
                ciudadInput.addEventListener('keydown', function(event) {
                    if (event.key === 'Enter') {
                        event.preventDefault(); // Prevenir el comportamiento por defecto
                        buscarCiudad();
                    }
                });
                
                // Tambi√©n agregar event listener para 'keypress' como respaldo
                ciudadInput.addEventListener('keypress', function(event) {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        buscarCiudad();
                    }
                });
            }
            
            initMap();
            loadWeatherData().then(() => {
                // Actualizar el marcador del mapa despu√©s de cargar los datos (por si se detect√≥ una nueva ubicaci√≥n)
                updateMapMarker();
            });
        });
    </script>
</body>
</html>
